<?hh // strict

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: example4.proto

class pb_Class implements \Protobuf\Message {
  public string $name;

  public function __construct() {
    $this->name = '';
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class pb_Interface implements \Protobuf\Message {
  public ?\pb_Class $class;

  public function __construct() {
    $this->class = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($this->class == null) $this->class = new \pb_Class();
          $this->class->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $msg = $this->class;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('class', 'class', $this->class, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'class':
          if ($v === null) break;
          if ($this->class == null) $this->class = new \pb_Class();
          $this->class->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class NotClass implements \Protobuf\Message {
  public string $name;

  public function __construct() {
    $this->name = '';
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class AndClient {
  public function __construct(private \Grpc\ClientConn $cc) {
  }

  public async function throw(\Grpc\Context $ctx, \pb_Class $in, \Grpc\CallOption ...$co): Awaitable<\google\protobuf\pb_Empty> {
    $out = new \google\protobuf\pb_Empty();
    await $this->cc->Invoke($ctx, '/And/throw', $in, $out, ...$co);
    return $out;
  }
}

interface AndServer {
  public function throw(\Grpc\Context $ctx, \pb_Class $in): \google\protobuf\pb_Empty;
}

function RegisterAndServer(\Grpc\Server $server, AndServer $service): void {
  $methods = vec[];
  $handler = function(\Grpc\Context $ctx, \Grpc\DecoderFunc $df): \Protobuf\Message use ($service) {
    $in = new \pb_Class();
    $df($in);
    return $service->throw($ctx, $in);
  };
  $methods []= new \Grpc\MethodDesc('throw', $handler);
  $server->RegisterService(new \Grpc\ServiceDesc('And', $methods));
}

class XXX_FileDescriptor_example4__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'example4.proto';
  const string RAW = 'eNp00cGO0zAQBmB7xnHc323TThBCuwuqKg7sJQsFHgAhDnDg0Dfobr3LoW2qJFB4FN4W2UmO3PLHM5/+OJiH37vj+RA+VOem7uqr66e6fjqEu5Tufz7eheO5+9Mfrq+RfT7s2lYE5rQ7hhd6pd9Mtul5fYvJ11MXmsfdQ5AbZA9xMk34ja3S3rZ/uX4F973u/ktt3oI/nfZyi6z70dQXGdavnld9u2psV32J7dbq21+GFaPUMw0HPRVWSjABsRKm/DVegowSY5XTm+VqG9rQ/Ar71aVu9m0FAGyUFrZuBg9jFCnhnAQzZDEYMTnZAtM+ZvHQjUkL55PZmFg4XywBkNFioKY66VoLwy2TrqPuB10n3RPKJGhSNh7mY9LC3s3GxMJ+0EnMXC16nbTw3C2STlEvBp2SXtBckkCpezF0p6QXQ3dKetHrVomReJsA2zglzkfdppsp6WNcsf3Hl9aPiYTL6XJMLFzevLu36W+9/xcAAP//e3BPDg';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
