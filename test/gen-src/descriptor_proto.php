<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: descriptor.proto

class FileDescriptorSet implements \Protobuf\Message {
  public vec<\google\protobuf\FileDescriptorProto> $file;

  public function __construct() {
    $this->file = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FileDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->file []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->file as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('file', 'file', $this->file);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'file':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FileDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->file []= $obj;
          }
          break;
      }
    }
  }
}

class FileDescriptorProto implements \Protobuf\Message {
  public string $name;
  public string $package;
  public vec<string> $dependency;
  public vec<int> $public_dependency;
  public vec<int> $weak_dependency;
  public vec<\google\protobuf\DescriptorProto> $message_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\ServiceDescriptorProto> $service;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public ?\google\protobuf\FileOptions $options;
  public ?\google\protobuf\SourceCodeInfo $source_code_info;
  public string $syntax;

  public function __construct() {
    $this->name = '';
    $this->package = '';
    $this->dependency = vec[];
    $this->public_dependency = vec[];
    $this->weak_dependency = vec[];
    $this->message_type = vec[];
    $this->enum_type = vec[];
    $this->service = vec[];
    $this->extension = vec[];
    $this->options = null;
    $this->source_code_info = null;
    $this->syntax = '';
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->package = $d->readString();
          break;
        case 3:
          $this->dependency []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->message_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\ServiceDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->service []= $obj;
          break;
        case 7:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 8:
          if ($this->options == null) $this->options = new \google\protobuf\FileOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          if ($this->source_code_info == null) $this->source_code_info = new \google\protobuf\SourceCodeInfo();
          $this->source_code_info->MergeFrom($d->readDecoder());
          break;
        case 10:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->public_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->public_dependency []= $d->readVarint32Signed();
          }
          break;
        case 11:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->weak_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->weak_dependency []= $d->readVarint32Signed();
          }
          break;
        case 12:
          $this->syntax = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->package !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->package);
    }
    foreach ($this->dependency as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->message_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->service as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    $msg = $this->source_code_info;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->public_dependency as $elem) {
      $e->writeTag(10, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->weak_dependency as $elem) {
      $e->writeTag(11, 0);
      $e->writeVarint($elem);
    }
    if ($this->syntax !== '') {
      $e->writeTag(12, 2);
      $e->writeString($this->syntax);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('package', 'package', $this->package, false);
    $e->writePrimitiveList('dependency', 'dependency', $this->dependency);
    $e->writeMessageList('message_type', 'messageType', $this->message_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('service', 'service', $this->service);
    $e->writeMessageList('extension', 'extension', $this->extension);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessage('source_code_info', 'sourceCodeInfo', $this->source_code_info, false);
    $e->writePrimitiveList('public_dependency', 'publicDependency', $this->public_dependency);
    $e->writePrimitiveList('weak_dependency', 'weakDependency', $this->weak_dependency);
    $e->writeString('syntax', 'syntax', $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'package':
          $this->package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'dependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->dependency []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'message_type': case 'messageType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->message_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'service':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ServiceDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->service []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\FileOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'source_code_info': case 'sourceCodeInfo':
          if ($v === null) break;
          if ($this->source_code_info == null) $this->source_code_info = new \google\protobuf\SourceCodeInfo();
          $this->source_code_info->MergeJsonFrom($v);
          break;
        case 'public_dependency': case 'publicDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->public_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'weak_dependency': case 'weakDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->weak_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'syntax':
          $this->syntax = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class DescriptorProto_ExtensionRange implements \Protobuf\Message {
  public int $start;
  public int $end;
  public ?\google\protobuf\ExtensionRangeOptions $options;

  public function __construct() {
    $this->start = 0;
    $this->end = 0;
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\ExtensionRangeOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\ExtensionRangeOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class DescriptorProto_ReservedRange implements \Protobuf\Message {
  public int $start;
  public int $end;

  public function __construct() {
    $this->start = 0;
    $this->end = 0;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
      }
    }
  }
}

class DescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\FieldDescriptorProto> $field;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public vec<\google\protobuf\DescriptorProto> $nested_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\DescriptorProto_ExtensionRange> $extension_range;
  public vec<\google\protobuf\OneofDescriptorProto> $oneof_decl;
  public ?\google\protobuf\MessageOptions $options;
  public vec<\google\protobuf\DescriptorProto_ReservedRange> $reserved_range;
  public vec<string> $reserved_name;

  public function __construct() {
    $this->name = '';
    $this->field = vec[];
    $this->extension = vec[];
    $this->nested_type = vec[];
    $this->enum_type = vec[];
    $this->extension_range = vec[];
    $this->oneof_decl = vec[];
    $this->options = null;
    $this->reserved_range = vec[];
    $this->reserved_name = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->field []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->nested_type []= $obj;
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
          $obj->MergeFrom($d->readDecoder());
          $this->extension_range []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 7:
          if ($this->options == null) $this->options = new \google\protobuf\MessageOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 8:
          $obj = new \google\protobuf\OneofDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_decl []= $obj;
          break;
        case 9:
          $obj = new \google\protobuf\DescriptorProto_ReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 10:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->field as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->nested_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->extension_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    foreach ($this->oneof_decl as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(10, 2);
      $e->writeString($elem);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('field', 'field', $this->field);
    $e->writeMessageList('nested_type', 'nestedType', $this->nested_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('extension_range', 'extensionRange', $this->extension_range);
    $e->writeMessageList('extension', 'extension', $this->extension);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessageList('oneof_decl', 'oneofDecl', $this->oneof_decl);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'field':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->field []= $obj;
          }
          break;
        case 'nested_type': case 'nestedType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->nested_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'extension_range': case 'extensionRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
            $obj->MergeJsonFrom($vv);
            $this->extension_range []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\MessageOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_decl': case 'oneofDecl':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\OneofDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->oneof_decl []= $obj;
          }
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
      }
    }
  }
}

class ExtensionRangeOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

newtype XXX_FieldDescriptorProto_Type_t as int = int;
abstract class FieldDescriptorProto_Type {
  const XXX_FieldDescriptorProto_Type_t TYPE_DOUBLE = 1;
  const XXX_FieldDescriptorProto_Type_t TYPE_FLOAT = 2;
  const XXX_FieldDescriptorProto_Type_t TYPE_INT64 = 3;
  const XXX_FieldDescriptorProto_Type_t TYPE_UINT64 = 4;
  const XXX_FieldDescriptorProto_Type_t TYPE_INT32 = 5;
  const XXX_FieldDescriptorProto_Type_t TYPE_FIXED64 = 6;
  const XXX_FieldDescriptorProto_Type_t TYPE_FIXED32 = 7;
  const XXX_FieldDescriptorProto_Type_t TYPE_BOOL = 8;
  const XXX_FieldDescriptorProto_Type_t TYPE_STRING = 9;
  const XXX_FieldDescriptorProto_Type_t TYPE_GROUP = 10;
  const XXX_FieldDescriptorProto_Type_t TYPE_MESSAGE = 11;
  const XXX_FieldDescriptorProto_Type_t TYPE_BYTES = 12;
  const XXX_FieldDescriptorProto_Type_t TYPE_UINT32 = 13;
  const XXX_FieldDescriptorProto_Type_t TYPE_ENUM = 14;
  const XXX_FieldDescriptorProto_Type_t TYPE_SFIXED32 = 15;
  const XXX_FieldDescriptorProto_Type_t TYPE_SFIXED64 = 16;
  const XXX_FieldDescriptorProto_Type_t TYPE_SINT32 = 17;
  const XXX_FieldDescriptorProto_Type_t TYPE_SINT64 = 18;
  private static dict<int, string> $XXX_itos = dict[
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldDescriptorProto_Type_t {
    if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if (is_int($m)) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldDescriptorProto_Type_t {
    return $i;
  }
}

newtype XXX_FieldDescriptorProto_Label_t as int = int;
abstract class FieldDescriptorProto_Label {
  const XXX_FieldDescriptorProto_Label_t LABEL_OPTIONAL = 1;
  const XXX_FieldDescriptorProto_Label_t LABEL_REQUIRED = 2;
  const XXX_FieldDescriptorProto_Label_t LABEL_REPEATED = 3;
  private static dict<int, string> $XXX_itos = dict[
    1 => 'LABEL_OPTIONAL',
    2 => 'LABEL_REQUIRED',
    3 => 'LABEL_REPEATED',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'LABEL_OPTIONAL' => 1,
    'LABEL_REQUIRED' => 2,
    'LABEL_REPEATED' => 3,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldDescriptorProto_Label_t {
    if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if (is_int($m)) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldDescriptorProto_Label_t {
    return $i;
  }
}

class FieldDescriptorProto implements \Protobuf\Message {
  public string $name;
  public int $number;
  public \google\protobuf\XXX_FieldDescriptorProto_Label_t $label;
  public \google\protobuf\XXX_FieldDescriptorProto_Type_t $type;
  public string $type_name;
  public string $extendee;
  public string $default_value;
  public int $oneof_index;
  public string $json_name;
  public ?\google\protobuf\FieldOptions $options;

  public function __construct() {
    $this->name = '';
    $this->number = 0;
    $this->label = \google\protobuf\FieldDescriptorProto_Label::XXX_FromInt(0);
    $this->type = \google\protobuf\FieldDescriptorProto_Type::XXX_FromInt(0);
    $this->type_name = '';
    $this->extendee = '';
    $this->default_value = '';
    $this->oneof_index = 0;
    $this->json_name = '';
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->extendee = $d->readString();
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          break;
        case 4:
          $this->label = \google\protobuf\FieldDescriptorProto_Label::XXX_FromInt($d->readVarint());
          break;
        case 5:
          $this->type = \google\protobuf\FieldDescriptorProto_Type::XXX_FromInt($d->readVarint());
          break;
        case 6:
          $this->type_name = $d->readString();
          break;
        case 7:
          $this->default_value = $d->readString();
          break;
        case 8:
          if ($this->options == null) $this->options = new \google\protobuf\FieldOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          $this->oneof_index = $d->readVarint32Signed();
          break;
        case 10:
          $this->json_name = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->extendee !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->extendee);
    }
    if ($this->number !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->label !== \google\protobuf\FieldDescriptorProto_Label::XXX_FromInt(0)) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->label);
    }
    if ($this->type !== \google\protobuf\FieldDescriptorProto_Type::XXX_FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->type);
    }
    if ($this->type_name !== '') {
      $e->writeTag(6, 2);
      $e->writeString($this->type_name);
    }
    if ($this->default_value !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->default_value);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    if ($this->oneof_index !== 0) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->json_name !== '') {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('extendee', 'extendee', $this->extendee, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeEnum('label', 'label', \google\protobuf\FieldDescriptorProto_Label::XXX_ItoS(), $this->label, false);
    $e->writeEnum('type', 'type', \google\protobuf\FieldDescriptorProto_Type::XXX_ItoS(), $this->type, false);
    $e->writeString('type_name', 'typeName', $this->type_name, false);
    $e->writeString('default_value', 'defaultValue', $this->default_value, false);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    $e->writeString('json_name', 'jsonName', $this->json_name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'extendee':
          $this->extendee = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'label':
          $this->label = \google\protobuf\FieldDescriptorProto_Label::XXX_FromMixed($v);
          break;
        case 'type':
          $this->type = \google\protobuf\FieldDescriptorProto_Type::XXX_FromMixed($v);
          break;
        case 'type_name': case 'typeName':
          $this->type_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\FieldOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class OneofDescriptorProto implements \Protobuf\Message {
  public string $name;
  public ?\google\protobuf\OneofOptions $options;

  public function __construct() {
    $this->name = '';
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          if ($this->options == null) $this->options = new \google\protobuf\OneofOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\OneofOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class EnumDescriptorProto_EnumReservedRange implements \Protobuf\Message {
  public int $start;
  public int $end;

  public function __construct() {
    $this->start = 0;
    $this->end = 0;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->start !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->end !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('start', 'start', $this->start, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
      }
    }
  }
}

class EnumDescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\EnumValueDescriptorProto> $value;
  public ?\google\protobuf\EnumOptions $options;
  public vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange> $reserved_range;
  public vec<string> $reserved_name;

  public function __construct() {
    $this->name = '';
    $this->value = vec[];
    $this->options = null;
    $this->reserved_range = vec[];
    $this->reserved_name = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\EnumValueDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->value []= $obj;
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\EnumOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 5:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(5, 2);
      $e->writeString($elem);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('value', 'value', $this->value);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValueDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->value []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\EnumOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
      }
    }
  }
}

class EnumValueDescriptorProto implements \Protobuf\Message {
  public string $name;
  public int $number;
  public ?\google\protobuf\EnumValueOptions $options;

  public function __construct() {
    $this->name = '';
    $this->number = 0;
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\EnumValueOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->number !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\EnumValueOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class ServiceDescriptorProto implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\MethodDescriptorProto> $method;
  public ?\google\protobuf\ServiceOptions $options;

  public function __construct() {
    $this->name = '';
    $this->method = vec[];
    $this->options = null;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\MethodDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->method []= $obj;
          break;
        case 3:
          if ($this->options == null) $this->options = new \google\protobuf\ServiceOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->method as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('method', 'method', $this->method);
    $e->writeMessage('options', 'options', $this->options, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'method':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\MethodDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->method []= $obj;
          }
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\ServiceOptions();
          $this->options->MergeJsonFrom($v);
          break;
      }
    }
  }
}

class MethodDescriptorProto implements \Protobuf\Message {
  public string $name;
  public string $input_type;
  public string $output_type;
  public ?\google\protobuf\MethodOptions $options;
  public bool $client_streaming;
  public bool $server_streaming;

  public function __construct() {
    $this->name = '';
    $this->input_type = '';
    $this->output_type = '';
    $this->options = null;
    $this->client_streaming = false;
    $this->server_streaming = false;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->input_type = $d->readString();
          break;
        case 3:
          $this->output_type = $d->readString();
          break;
        case 4:
          if ($this->options == null) $this->options = new \google\protobuf\MethodOptions();
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->client_streaming = $d->readBool();
          break;
        case 6:
          $this->server_streaming = $d->readBool();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->input_type !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->input_type);
    }
    if ($this->output_type !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->output_type);
    }
    $msg = $this->options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    if ($this->client_streaming !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->client_streaming);
    }
    if ($this->server_streaming !== false) {
      $e->writeTag(6, 0);
      $e->writeBool($this->server_streaming);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('input_type', 'inputType', $this->input_type, false);
    $e->writeString('output_type', 'outputType', $this->output_type, false);
    $e->writeMessage('options', 'options', $this->options, false);
    $e->writeBool('client_streaming', 'clientStreaming', $this->client_streaming, false);
    $e->writeBool('server_streaming', 'serverStreaming', $this->server_streaming, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'input_type': case 'inputType':
          $this->input_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'output_type': case 'outputType':
          $this->output_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'options':
          if ($v === null) break;
          if ($this->options == null) $this->options = new \google\protobuf\MethodOptions();
          $this->options->MergeJsonFrom($v);
          break;
        case 'client_streaming': case 'clientStreaming':
          $this->client_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'server_streaming': case 'serverStreaming':
          $this->server_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
      }
    }
  }
}

newtype XXX_FileOptions_OptimizeMode_t as int = int;
abstract class FileOptions_OptimizeMode {
  const XXX_FileOptions_OptimizeMode_t SPEED = 1;
  const XXX_FileOptions_OptimizeMode_t CODE_SIZE = 2;
  const XXX_FileOptions_OptimizeMode_t LITE_RUNTIME = 3;
  private static dict<int, string> $XXX_itos = dict[
    1 => 'SPEED',
    2 => 'CODE_SIZE',
    3 => 'LITE_RUNTIME',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'SPEED' => 1,
    'CODE_SIZE' => 2,
    'LITE_RUNTIME' => 3,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FileOptions_OptimizeMode_t {
    if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if (is_int($m)) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FileOptions_OptimizeMode_t {
    return $i;
  }
}

class FileOptions implements \Protobuf\Message {
  public string $java_package;
  public string $java_outer_classname;
  public bool $java_multiple_files;
  public bool $java_generate_equals_and_hash;
  public bool $java_string_check_utf8;
  public \google\protobuf\XXX_FileOptions_OptimizeMode_t $optimize_for;
  public string $go_package;
  public bool $cc_generic_services;
  public bool $java_generic_services;
  public bool $py_generic_services;
  public bool $php_generic_services;
  public bool $deprecated;
  public bool $cc_enable_arenas;
  public string $objc_class_prefix;
  public string $csharp_namespace;
  public string $swift_prefix;
  public string $php_class_prefix;
  public string $php_namespace;
  public string $php_metadata_namespace;
  public string $ruby_package;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->java_package = '';
    $this->java_outer_classname = '';
    $this->java_multiple_files = false;
    $this->java_generate_equals_and_hash = false;
    $this->java_string_check_utf8 = false;
    $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::XXX_FromInt(0);
    $this->go_package = '';
    $this->cc_generic_services = false;
    $this->java_generic_services = false;
    $this->py_generic_services = false;
    $this->php_generic_services = false;
    $this->deprecated = false;
    $this->cc_enable_arenas = false;
    $this->objc_class_prefix = '';
    $this->csharp_namespace = '';
    $this->swift_prefix = '';
    $this->php_class_prefix = '';
    $this->php_namespace = '';
    $this->php_metadata_namespace = '';
    $this->ruby_package = '';
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->java_package = $d->readString();
          break;
        case 8:
          $this->java_outer_classname = $d->readString();
          break;
        case 9:
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::XXX_FromInt($d->readVarint());
          break;
        case 10:
          $this->java_multiple_files = $d->readBool();
          break;
        case 11:
          $this->go_package = $d->readString();
          break;
        case 16:
          $this->cc_generic_services = $d->readBool();
          break;
        case 17:
          $this->java_generic_services = $d->readBool();
          break;
        case 18:
          $this->py_generic_services = $d->readBool();
          break;
        case 20:
          $this->java_generate_equals_and_hash = $d->readBool();
          break;
        case 23:
          $this->deprecated = $d->readBool();
          break;
        case 27:
          $this->java_string_check_utf8 = $d->readBool();
          break;
        case 31:
          $this->cc_enable_arenas = $d->readBool();
          break;
        case 36:
          $this->objc_class_prefix = $d->readString();
          break;
        case 37:
          $this->csharp_namespace = $d->readString();
          break;
        case 39:
          $this->swift_prefix = $d->readString();
          break;
        case 40:
          $this->php_class_prefix = $d->readString();
          break;
        case 41:
          $this->php_namespace = $d->readString();
          break;
        case 42:
          $this->php_generic_services = $d->readBool();
          break;
        case 44:
          $this->php_metadata_namespace = $d->readString();
          break;
        case 45:
          $this->ruby_package = $d->readString();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->java_package !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->java_package);
    }
    if ($this->java_outer_classname !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->java_outer_classname);
    }
    if ($this->optimize_for !== \google\protobuf\FileOptions_OptimizeMode::XXX_FromInt(0)) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->optimize_for);
    }
    if ($this->java_multiple_files !== false) {
      $e->writeTag(10, 0);
      $e->writeBool($this->java_multiple_files);
    }
    if ($this->go_package !== '') {
      $e->writeTag(11, 2);
      $e->writeString($this->go_package);
    }
    if ($this->cc_generic_services !== false) {
      $e->writeTag(16, 0);
      $e->writeBool($this->cc_generic_services);
    }
    if ($this->java_generic_services !== false) {
      $e->writeTag(17, 0);
      $e->writeBool($this->java_generic_services);
    }
    if ($this->py_generic_services !== false) {
      $e->writeTag(18, 0);
      $e->writeBool($this->py_generic_services);
    }
    if ($this->java_generate_equals_and_hash !== false) {
      $e->writeTag(20, 0);
      $e->writeBool($this->java_generate_equals_and_hash);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(23, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->java_string_check_utf8 !== false) {
      $e->writeTag(27, 0);
      $e->writeBool($this->java_string_check_utf8);
    }
    if ($this->cc_enable_arenas !== false) {
      $e->writeTag(31, 0);
      $e->writeBool($this->cc_enable_arenas);
    }
    if ($this->objc_class_prefix !== '') {
      $e->writeTag(36, 2);
      $e->writeString($this->objc_class_prefix);
    }
    if ($this->csharp_namespace !== '') {
      $e->writeTag(37, 2);
      $e->writeString($this->csharp_namespace);
    }
    if ($this->swift_prefix !== '') {
      $e->writeTag(39, 2);
      $e->writeString($this->swift_prefix);
    }
    if ($this->php_class_prefix !== '') {
      $e->writeTag(40, 2);
      $e->writeString($this->php_class_prefix);
    }
    if ($this->php_namespace !== '') {
      $e->writeTag(41, 2);
      $e->writeString($this->php_namespace);
    }
    if ($this->php_generic_services !== false) {
      $e->writeTag(42, 0);
      $e->writeBool($this->php_generic_services);
    }
    if ($this->php_metadata_namespace !== '') {
      $e->writeTag(44, 2);
      $e->writeString($this->php_metadata_namespace);
    }
    if ($this->ruby_package !== '') {
      $e->writeTag(45, 2);
      $e->writeString($this->ruby_package);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('java_package', 'javaPackage', $this->java_package, false);
    $e->writeString('java_outer_classname', 'javaOuterClassname', $this->java_outer_classname, false);
    $e->writeEnum('optimize_for', 'optimizeFor', \google\protobuf\FileOptions_OptimizeMode::XXX_ItoS(), $this->optimize_for, false);
    $e->writeBool('java_multiple_files', 'javaMultipleFiles', $this->java_multiple_files, false);
    $e->writeString('go_package', 'goPackage', $this->go_package, false);
    $e->writeBool('cc_generic_services', 'ccGenericServices', $this->cc_generic_services, false);
    $e->writeBool('java_generic_services', 'javaGenericServices', $this->java_generic_services, false);
    $e->writeBool('py_generic_services', 'pyGenericServices', $this->py_generic_services, false);
    $e->writeBool('java_generate_equals_and_hash', 'javaGenerateEqualsAndHash', $this->java_generate_equals_and_hash, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('java_string_check_utf8', 'javaStringCheckUtf8', $this->java_string_check_utf8, false);
    $e->writeBool('cc_enable_arenas', 'ccEnableArenas', $this->cc_enable_arenas, false);
    $e->writeString('objc_class_prefix', 'objcClassPrefix', $this->objc_class_prefix, false);
    $e->writeString('csharp_namespace', 'csharpNamespace', $this->csharp_namespace, false);
    $e->writeString('swift_prefix', 'swiftPrefix', $this->swift_prefix, false);
    $e->writeString('php_class_prefix', 'phpClassPrefix', $this->php_class_prefix, false);
    $e->writeString('php_namespace', 'phpNamespace', $this->php_namespace, false);
    $e->writeBool('php_generic_services', 'phpGenericServices', $this->php_generic_services, false);
    $e->writeString('php_metadata_namespace', 'phpMetadataNamespace', $this->php_metadata_namespace, false);
    $e->writeString('ruby_package', 'rubyPackage', $this->ruby_package, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'java_package': case 'javaPackage':
          $this->java_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'java_outer_classname': case 'javaOuterClassname':
          $this->java_outer_classname = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optimize_for': case 'optimizeFor':
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::XXX_FromMixed($v);
          break;
        case 'java_multiple_files': case 'javaMultipleFiles':
          $this->java_multiple_files = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'go_package': case 'goPackage':
          $this->go_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'cc_generic_services': case 'ccGenericServices':
          $this->cc_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_generic_services': case 'javaGenericServices':
          $this->java_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'py_generic_services': case 'pyGenericServices':
          $this->py_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_generate_equals_and_hash': case 'javaGenerateEqualsAndHash':
          $this->java_generate_equals_and_hash = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'java_string_check_utf8': case 'javaStringCheckUtf8':
          $this->java_string_check_utf8 = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'cc_enable_arenas': case 'ccEnableArenas':
          $this->cc_enable_arenas = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'objc_class_prefix': case 'objcClassPrefix':
          $this->objc_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'csharp_namespace': case 'csharpNamespace':
          $this->csharp_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'swift_prefix': case 'swiftPrefix':
          $this->swift_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_class_prefix': case 'phpClassPrefix':
          $this->php_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_namespace': case 'phpNamespace':
          $this->php_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'php_generic_services': case 'phpGenericServices':
          $this->php_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'php_metadata_namespace': case 'phpMetadataNamespace':
          $this->php_metadata_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'ruby_package': case 'rubyPackage':
          $this->ruby_package = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class MessageOptions implements \Protobuf\Message {
  public bool $message_set_wire_format;
  public bool $no_standard_descriptor_accessor;
  public bool $deprecated;
  public bool $map_entry;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->message_set_wire_format = false;
    $this->no_standard_descriptor_accessor = false;
    $this->deprecated = false;
    $this->map_entry = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->message_set_wire_format = $d->readBool();
          break;
        case 2:
          $this->no_standard_descriptor_accessor = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 7:
          $this->map_entry = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->message_set_wire_format !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->message_set_wire_format);
    }
    if ($this->no_standard_descriptor_accessor !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->no_standard_descriptor_accessor);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->map_entry !== false) {
      $e->writeTag(7, 0);
      $e->writeBool($this->map_entry);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('message_set_wire_format', 'messageSetWireFormat', $this->message_set_wire_format, false);
    $e->writeBool('no_standard_descriptor_accessor', 'noStandardDescriptorAccessor', $this->no_standard_descriptor_accessor, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('map_entry', 'mapEntry', $this->map_entry, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'message_set_wire_format': case 'messageSetWireFormat':
          $this->message_set_wire_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'no_standard_descriptor_accessor': case 'noStandardDescriptorAccessor':
          $this->no_standard_descriptor_accessor = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'map_entry': case 'mapEntry':
          $this->map_entry = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

newtype XXX_FieldOptions_CType_t as int = int;
abstract class FieldOptions_CType {
  const XXX_FieldOptions_CType_t STRING = 0;
  const XXX_FieldOptions_CType_t CORD = 1;
  const XXX_FieldOptions_CType_t STRING_PIECE = 2;
  private static dict<int, string> $XXX_itos = dict[
    0 => 'STRING',
    1 => 'CORD',
    2 => 'STRING_PIECE',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'STRING' => 0,
    'CORD' => 1,
    'STRING_PIECE' => 2,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldOptions_CType_t {
    if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if (is_int($m)) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldOptions_CType_t {
    return $i;
  }
}

newtype XXX_FieldOptions_JSType_t as int = int;
abstract class FieldOptions_JSType {
  const XXX_FieldOptions_JSType_t JS_NORMAL = 0;
  const XXX_FieldOptions_JSType_t JS_STRING = 1;
  const XXX_FieldOptions_JSType_t JS_NUMBER = 2;
  private static dict<int, string> $XXX_itos = dict[
    0 => 'JS_NORMAL',
    1 => 'JS_STRING',
    2 => 'JS_NUMBER',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'JS_NORMAL' => 0,
    'JS_STRING' => 1,
    'JS_NUMBER' => 2,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_FieldOptions_JSType_t {
    if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if (is_int($m)) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_FieldOptions_JSType_t {
    return $i;
  }
}

class FieldOptions implements \Protobuf\Message {
  public \google\protobuf\XXX_FieldOptions_CType_t $ctype;
  public bool $packed;
  public \google\protobuf\XXX_FieldOptions_JSType_t $jstype;
  public bool $lazy;
  public bool $deprecated;
  public bool $weak;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->ctype = \google\protobuf\FieldOptions_CType::XXX_FromInt(0);
    $this->packed = false;
    $this->jstype = \google\protobuf\FieldOptions_JSType::XXX_FromInt(0);
    $this->lazy = false;
    $this->deprecated = false;
    $this->weak = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->ctype = \google\protobuf\FieldOptions_CType::XXX_FromInt($d->readVarint());
          break;
        case 2:
          $this->packed = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 5:
          $this->lazy = $d->readBool();
          break;
        case 6:
          $this->jstype = \google\protobuf\FieldOptions_JSType::XXX_FromInt($d->readVarint());
          break;
        case 10:
          $this->weak = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->ctype !== \google\protobuf\FieldOptions_CType::XXX_FromInt(0)) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->ctype);
    }
    if ($this->packed !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->packed);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->lazy !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->lazy);
    }
    if ($this->jstype !== \google\protobuf\FieldOptions_JSType::XXX_FromInt(0)) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->jstype);
    }
    if ($this->weak !== false) {
      $e->writeTag(10, 0);
      $e->writeBool($this->weak);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('ctype', 'ctype', \google\protobuf\FieldOptions_CType::XXX_ItoS(), $this->ctype, false);
    $e->writeBool('packed', 'packed', $this->packed, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeBool('lazy', 'lazy', $this->lazy, false);
    $e->writeEnum('jstype', 'jstype', \google\protobuf\FieldOptions_JSType::XXX_ItoS(), $this->jstype, false);
    $e->writeBool('weak', 'weak', $this->weak, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'ctype':
          $this->ctype = \google\protobuf\FieldOptions_CType::XXX_FromMixed($v);
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'lazy':
          $this->lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'jstype':
          $this->jstype = \google\protobuf\FieldOptions_JSType::XXX_FromMixed($v);
          break;
        case 'weak':
          $this->weak = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class OneofOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class EnumOptions implements \Protobuf\Message {
  public bool $allow_alias;
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->allow_alias = false;
    $this->deprecated = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->allow_alias = $d->readBool();
          break;
        case 3:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->allow_alias !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->allow_alias);
    }
    if ($this->deprecated !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('allow_alias', 'allowAlias', $this->allow_alias, false);
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'allow_alias': case 'allowAlias':
          $this->allow_alias = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class EnumValueOptions implements \Protobuf\Message {
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->deprecated = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class ServiceOptions implements \Protobuf\Message {
  public bool $deprecated;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->deprecated = false;
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

newtype XXX_MethodOptions_IdempotencyLevel_t as int = int;
abstract class MethodOptions_IdempotencyLevel {
  const XXX_MethodOptions_IdempotencyLevel_t IDEMPOTENCY_UNKNOWN = 0;
  const XXX_MethodOptions_IdempotencyLevel_t NO_SIDE_EFFECTS = 1;
  const XXX_MethodOptions_IdempotencyLevel_t IDEMPOTENT = 2;
  private static dict<int, string> $XXX_itos = dict[
    0 => 'IDEMPOTENCY_UNKNOWN',
    1 => 'NO_SIDE_EFFECTS',
    2 => 'IDEMPOTENT',
  ];
  public static function XXX_ItoS(): dict<int, string> {
    return self::$XXX_itos;
  }
  private static dict<string, int> $XXX_stoi = dict[
    'IDEMPOTENCY_UNKNOWN' => 0,
    'NO_SIDE_EFFECTS' => 1,
    'IDEMPOTENT' => 2,
  ];
  public static function XXX_FromMixed(mixed $m): XXX_MethodOptions_IdempotencyLevel_t {
    if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);
    if (is_int($m)) return $m;
    return 0;
  }
  public static function XXX_FromInt(int $i): XXX_MethodOptions_IdempotencyLevel_t {
    return $i;
  }
}

class MethodOptions implements \Protobuf\Message {
  public bool $deprecated;
  public \google\protobuf\XXX_MethodOptions_IdempotencyLevel_t $idempotency_level;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;

  public function __construct() {
    $this->deprecated = false;
    $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromInt(0);
    $this->uninterpreted_option = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          break;
        case 34:
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromInt($d->readVarint());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->deprecated !== false) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->idempotency_level !== \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromInt(0)) {
      $e->writeTag(34, 0);
      $e->writeVarint($this->idempotency_level);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    $e->writeEnum('idempotency_level', 'idempotencyLevel', \google\protobuf\MethodOptions_IdempotencyLevel::XXX_ItoS(), $this->idempotency_level, false);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'idempotency_level': case 'idempotencyLevel':
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::XXX_FromMixed($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
      }
    }
  }
}

class UninterpretedOption_NamePart implements \Protobuf\Message {
  public string $name_part;
  public bool $is_extension;

  public function __construct() {
    $this->name_part = '';
    $this->is_extension = false;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name_part = $d->readString();
          break;
        case 2:
          $this->is_extension = $d->readBool();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name_part !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name_part);
    }
    if ($this->is_extension !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->is_extension);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name_part', 'namePart', $this->name_part, false);
    $e->writeBool('is_extension', 'isExtension', $this->is_extension, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name_part': case 'namePart':
          $this->name_part = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'is_extension': case 'isExtension':
          $this->is_extension = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
      }
    }
  }
}

class UninterpretedOption implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption_NamePart> $name;
  public string $identifier_value;
  public int $positive_int_value;
  public int $negative_int_value;
  public float $double_value;
  public string $string_value;
  public string $aggregate_value;

  public function __construct() {
    $this->name = vec[];
    $this->identifier_value = '';
    $this->positive_int_value = 0;
    $this->negative_int_value = 0;
    $this->double_value = 0.0;
    $this->string_value = '';
    $this->aggregate_value = '';
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\UninterpretedOption_NamePart();
          $obj->MergeFrom($d->readDecoder());
          $this->name []= $obj;
          break;
        case 3:
          $this->identifier_value = $d->readString();
          break;
        case 4:
          $this->positive_int_value = $d->readVarint();
          break;
        case 5:
          $this->negative_int_value = $d->readVarint();
          break;
        case 6:
          $this->double_value = $d->readDouble();
          break;
        case 7:
          $this->string_value = $d->readString();
          break;
        case 8:
          $this->aggregate_value = $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->name as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->identifier_value !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->identifier_value);
    }
    if ($this->positive_int_value !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->positive_int_value);
    }
    if ($this->negative_int_value !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->negative_int_value);
    }
    if ($this->double_value !== 0.0) {
      $e->writeTag(6, 1);
      $e->writeDouble($this->double_value);
    }
    if ($this->string_value !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->string_value);
    }
    if ($this->aggregate_value !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->aggregate_value);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('name', 'name', $this->name);
    $e->writeString('identifier_value', 'identifierValue', $this->identifier_value, false);
    $e->writeInt64Unsigned('positive_int_value', 'positiveIntValue', $this->positive_int_value, false);
    $e->writeInt64Signed('negative_int_value', 'negativeIntValue', $this->negative_int_value, false);
    $e->writeFloat('double_value', 'doubleValue', $this->double_value, false);
    $e->writeBytes('string_value', 'stringValue', $this->string_value, false);
    $e->writeString('aggregate_value', 'aggregateValue', $this->aggregate_value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption_NamePart();
            $obj->MergeJsonFrom($vv);
            $this->name []= $obj;
          }
          break;
        case 'identifier_value': case 'identifierValue':
          $this->identifier_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'positive_int_value': case 'positiveIntValue':
          $this->positive_int_value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'negative_int_value': case 'negativeIntValue':
          $this->negative_int_value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'double_value': case 'doubleValue':
          $this->double_value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'string_value': case 'stringValue':
          $this->string_value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'aggregate_value': case 'aggregateValue':
          $this->aggregate_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
      }
    }
  }
}

class SourceCodeInfo_Location implements \Protobuf\Message {
  public vec<int> $path;
  public vec<int> $span;
  public string $leading_comments;
  public string $trailing_comments;
  public vec<string> $leading_detached_comments;

  public function __construct() {
    $this->path = vec[];
    $this->span = vec[];
    $this->leading_comments = '';
    $this->trailing_comments = '';
    $this->leading_detached_comments = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->span []= $packed->readVarint32Signed();
            }
          } else {
            $this->span []= $d->readVarint32Signed();
          }
          break;
        case 3:
          $this->leading_comments = $d->readString();
          break;
        case 4:
          $this->trailing_comments = $d->readString();
          break;
        case 6:
          $this->leading_detached_comments []= $d->readString();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->path as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 1);
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->span as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 2);
    if ($this->leading_comments !== '') {
      $e->writeTag(3, 2);
      $e->writeString($this->leading_comments);
    }
    if ($this->trailing_comments !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->trailing_comments);
    }
    foreach ($this->leading_detached_comments as $elem) {
      $e->writeTag(6, 2);
      $e->writeString($elem);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writePrimitiveList('span', 'span', $this->span);
    $e->writeString('leading_comments', 'leadingComments', $this->leading_comments, false);
    $e->writeString('trailing_comments', 'trailingComments', $this->trailing_comments, false);
    $e->writePrimitiveList('leading_detached_comments', 'leadingDetachedComments', $this->leading_detached_comments);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'span':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->span []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'leading_comments': case 'leadingComments':
          $this->leading_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'trailing_comments': case 'trailingComments':
          $this->trailing_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'leading_detached_comments': case 'leadingDetachedComments':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->leading_detached_comments []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
      }
    }
  }
}

class SourceCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\SourceCodeInfo_Location> $location;

  public function __construct() {
    $this->location = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\SourceCodeInfo_Location();
          $obj->MergeFrom($d->readDecoder());
          $this->location []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->location as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('location', 'location', $this->location);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'location':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\SourceCodeInfo_Location();
            $obj->MergeJsonFrom($vv);
            $this->location []= $obj;
          }
          break;
      }
    }
  }
}

class GeneratedCodeInfo_Annotation implements \Protobuf\Message {
  public vec<int> $path;
  public string $source_file;
  public int $begin;
  public int $end;

  public function __construct() {
    $this->path = vec[];
    $this->source_file = '';
    $this->begin = 0;
    $this->end = 0;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          $this->source_file = $d->readString();
          break;
        case 3:
          $this->begin = $d->readVarint32Signed();
          break;
        case 4:
          $this->end = $d->readVarint32Signed();
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $packed = new \Protobuf\Internal\Encoder();
    foreach ($this->path as $elem) {
      $packed->writeVarint($elem);
    }
    $e->writeEncoder($packed, 1);
    if ($this->source_file !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->source_file);
    }
    if ($this->begin !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->begin);
    }
    if ($this->end !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->end);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writeString('source_file', 'sourceFile', $this->source_file, false);
    $e->writeInt32('begin', 'begin', $this->begin, false);
    $e->writeInt32('end', 'end', $this->end, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'source_file': case 'sourceFile':
          $this->source_file = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'begin':
          $this->begin = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
      }
    }
  }
}

class GeneratedCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\GeneratedCodeInfo_Annotation> $annotation;

  public function __construct() {
    $this->annotation = vec[];
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
          $obj->MergeFrom($d->readDecoder());
          $this->annotation []= $obj;
          break;
        default:
          $d->skipWireType($wt);
      }
    }
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->annotation as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('annotation', 'annotation', $this->annotation);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'annotation':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
            $obj->MergeJsonFrom($vv);
            $this->annotation []= $obj;
          }
          break;
      }
    }
  }
}


class XXX_FileDescriptor_descriptor__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'descriptor.proto';
  const string RAW = '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';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    return (string)\gzuncompress(\base64_decode(self::RAW));
  }
}
