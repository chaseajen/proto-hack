package main

import (
	"bytes"
	"compress/flate"
	"compress/zlib"
	"encoding/base64"
	"fmt"
	"github.com/golang/protobuf/proto"
	desc "github.com/golang/protobuf/protoc-gen-go/descriptor"
	ppb "github.com/golang/protobuf/protoc-gen-go/plugin"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	specialPrefix = "XXX_"
	genDebug      = false
	libNs         = "\\Protobuf"
	libNsInternal = libNs + "\\Internal"
)

func main() {
	var buf bytes.Buffer
	_, err := buf.ReadFrom(os.Stdin)
	if err != nil {
		panic(fmt.Errorf("error reading from stdin: %v", err))
	}
	out, err := codeGenerator(buf.Bytes())
	if err != nil {
		panic(err)
	}
	os.Stdout.Write(out)
}

func codeGenerator(b []byte) ([]byte, error) {
	req := ppb.CodeGeneratorRequest{}
	err := proto.Unmarshal(b, &req)
	if err != nil {
		return nil, fmt.Errorf("error unmarshaling CodeGeneratorRequest: %v", err)
	}
	resp := gen(&req)
	out, err := proto.Marshal(resp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling CodeGeneratorResponse: %v", err)
	}
	return out, nil
}

func gen(req *ppb.CodeGeneratorRequest) *ppb.CodeGeneratorResponse {
	resp := &ppb.CodeGeneratorResponse{}
	fileToGenerate := map[string]bool{}
	for _, f := range req.FileToGenerate {
		fileToGenerate[f] = true
	}
	genService := strings.Contains(req.GetParameter(), "plugins=grpc")
	genService = genService || strings.Contains(req.GetParameter(), "plugin=grpc")

	rootns := NewEmptyNamespace()
	for _, fdp := range req.ProtoFile {
		if *fdp.Syntax != "proto3" {
			panic(fmt.Errorf("unsupported syntax: %s in file %s", *fdp.Syntax, *fdp.Name))
		}
		rootns.Parse(fdp)
		// panic(rootns.PrettyPrint())

		if !fileToGenerate[*fdp.Name] {
			continue
		}
		f := &ppb.CodeGeneratorResponse_File{}

		fext := filepath.Ext(*fdp.Name)
		fname := strings.TrimSuffix(*fdp.Name, fext) + "_proto.php"
		f.Name = proto.String(fname)

		b := &bytes.Buffer{}
		w := &writer{b, 0}
		writeFile(w, fdp, rootns, genService)
		f.Content = proto.String(b.String())
		resp.File = append(resp.File, f)
	}
	return resp
}

func writeFile(w *writer, fdp *desc.FileDescriptorProto, rootNs *Namespace, genService bool) {
	packageParts := strings.Split(fdp.GetPackage(), ".")
	ns := rootNs.FindFullyQualifiedNamespace("." + fdp.GetPackage())
	if ns == nil {
		panic("unable to find namespace for: " + fdp.GetPackage())
	}

	// File header.
	w.p("<?hh // strict")
	w.p("namespace %s;", strings.Join(packageParts, "\\"))
	w.ln()
	w.p("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	w.p("// Source: %s", fdp.GetName())
	w.ln()

	// Top level enums.
	for _, edp := range fdp.EnumType {
		writeEnum(w, edp, nil)
	}

	// Messages, recurse.
	for _, dp := range fdp.MessageType {
		writeDescriptor(w, dp, ns, nil)
	}

	// Write services.
	if genService {
		for _, sdp := range fdp.Service {
			writeService(w, sdp, fdp.GetPackage(), ns)
		}
	}

	// Write file descriptor.
	w.ln()
	fdClassName := strings.Replace(fdp.GetName(), "/", "_", -1)
	fdClassName = strings.Replace(fdClassName, ".", "__", -1)
	fdClassName = specialPrefix + "FileDescriptor_" + fdClassName
	w.p("class %s implements %s\\FileDescriptor {", fdClassName, libNsInternal)
	w.p("const string NAME = '%s';", fdp.GetName())
	w.p("const string RAW = '%s';", toPhpString(fdp))
	w.p("public function Name(): string {")
	w.p("return self::NAME;")
	w.p("}")
	w.ln()
	w.p("public function FileDescriptorProtoBytes(): string {")
	w.p("return (string)\\gzuncompress(\\base64_decode(self::RAW));")
	w.p("}")
	w.p("}")
}

func toPhpString(fdp *desc.FileDescriptorProto) string {
	bfdp, err := proto.Marshal(fdp)
	if err != nil {
		panic(err)
	}
	var b bytes.Buffer
	gz, err := zlib.NewWriterLevel(&b, flate.BestCompression)
	if err != nil {
		panic(err)
	}
	if _, err = gz.Write(bfdp); err != nil {
		panic(err)
	}
	if err = gz.Close(); err != nil {
		panic(err)
	}
	str := base64.RawStdEncoding.EncodeToString(b.Bytes())
	return str
}

func toPhpName(ns, name string) (string, string) {
	return strings.Replace(ns, ".", "\\", -1), strings.Replace(name, ".", "_", -1)
}

type field struct {
	fd                     *desc.FieldDescriptorProto
	typePhpNs, typePhpName string
	typeDescriptor         interface{}
	typeNs                 *Namespace
	typeEnumDefault        string
	isMap                  bool
	oneof                  *oneof
}

func newField(fd *desc.FieldDescriptorProto, ns *Namespace) *field {
	f := &field{
		fd: fd,
	}
	if fd.GetTypeName() != "" {
		typeNs, typeName, i := ns.FindFullyQualifiedName(fd.GetTypeName())
		f.typePhpNs, f.typePhpName = toPhpName(typeNs, typeName)
		f.typeDescriptor = i
		f.typeNs = ns.FindFullyQualifiedNamespace(typeNs)
		if dp, ok := f.typeDescriptor.(*desc.DescriptorProto); ok {
			if dp.GetOptions().GetMapEntry() {
				f.isMap = true
			}
		}
		if ed, ok := f.typeDescriptor.(*desc.EnumDescriptorProto); ok {
			for _, v := range ed.Value {
				if v.GetNumber() == 0 {
					f.typeEnumDefault = v.GetName()
					break
				}
			}
		}

	}

	return f
}

func (f field) mapFields() (*field, *field) {
	dp := f.typeDescriptor.(*desc.DescriptorProto)
	keyField := newField(dp.Field[0], f.typeNs)
	valueField := newField(dp.Field[1], f.typeNs)
	return keyField, valueField
}

func (f field) phpType() string {
	switch t := *f.fd.Type; t {
	case desc.FieldDescriptorProto_TYPE_STRING, desc.FieldDescriptorProto_TYPE_BYTES:
		return "string"
	case desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_INT32, desc.FieldDescriptorProto_TYPE_UINT64, desc.FieldDescriptorProto_TYPE_UINT32, desc.FieldDescriptorProto_TYPE_SINT64, desc.FieldDescriptorProto_TYPE_SINT32, desc.FieldDescriptorProto_TYPE_FIXED32, desc.FieldDescriptorProto_TYPE_FIXED64, desc.FieldDescriptorProto_TYPE_SFIXED32, desc.FieldDescriptorProto_TYPE_SFIXED64:
		return "int"
	case desc.FieldDescriptorProto_TYPE_FLOAT, desc.FieldDescriptorProto_TYPE_DOUBLE:
		return "float"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		return "bool"
	case desc.FieldDescriptorProto_TYPE_MESSAGE:
		return f.typePhpNs + "\\" + f.typePhpName
	case desc.FieldDescriptorProto_TYPE_ENUM:
		return f.typePhpNs + "\\" + specialPrefix + f.typePhpName + "_t"
	default:
		panic(fmt.Errorf("unexpected proto type while converting to php type: %v", t))
	}
}

func (f field) defaultValue() string {
	if f.isMap {
		return "dict[]"
	}
	if f.isRepeated() {
		return "vec[]"
	}
	switch t := *f.fd.Type; t {
	case desc.FieldDescriptorProto_TYPE_STRING, desc.FieldDescriptorProto_TYPE_BYTES:
		return "''"
	case desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_INT32, desc.FieldDescriptorProto_TYPE_UINT64, desc.FieldDescriptorProto_TYPE_UINT32, desc.FieldDescriptorProto_TYPE_SINT64, desc.FieldDescriptorProto_TYPE_SINT32, desc.FieldDescriptorProto_TYPE_FIXED32, desc.FieldDescriptorProto_TYPE_FIXED64, desc.FieldDescriptorProto_TYPE_SFIXED32, desc.FieldDescriptorProto_TYPE_SFIXED64:
		return "0"
	case desc.FieldDescriptorProto_TYPE_FLOAT, desc.FieldDescriptorProto_TYPE_DOUBLE:
		return "0.0"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		return "false"
	case desc.FieldDescriptorProto_TYPE_ENUM:
		return f.typePhpNs + "\\" + f.typePhpName + "::" + f.typeEnumDefault
	case desc.FieldDescriptorProto_TYPE_MESSAGE:
		return "null"
	default:
		panic(fmt.Errorf("unexpected proto type while converting to default value: %v", t))
	}
}

func (f field) isRepeated() bool {
	return *f.fd.Label == desc.FieldDescriptorProto_LABEL_REPEATED
}

func (f field) labeledType() string {
	if f.isMap {
		k, v := f.mapFields()
		return fmt.Sprintf("dict<%s, %s>", k.phpType(), v.labeledType())
	}
	if f.isRepeated() {
		return "vec<" + f.phpType() + ">"
	}
	if *f.fd.Type == desc.FieldDescriptorProto_TYPE_MESSAGE {
		return "?" + f.phpType()
	}
	return f.phpType()
}

func (f field) varName() string {
	return f.fd.GetName()
}

// Default is 0
var writeWireType = map[desc.FieldDescriptorProto_Type]int{
	desc.FieldDescriptorProto_TYPE_FLOAT:    5,
	desc.FieldDescriptorProto_TYPE_DOUBLE:   1,
	desc.FieldDescriptorProto_TYPE_FIXED32:  5,
	desc.FieldDescriptorProto_TYPE_SFIXED32: 5,
	desc.FieldDescriptorProto_TYPE_FIXED64:  1,
	desc.FieldDescriptorProto_TYPE_SFIXED64: 1,
	desc.FieldDescriptorProto_TYPE_STRING:   2,
	desc.FieldDescriptorProto_TYPE_BYTES:    2,
	desc.FieldDescriptorProto_TYPE_MESSAGE:  2,
}

var isPackable = map[desc.FieldDescriptorProto_Type]bool{
	desc.FieldDescriptorProto_TYPE_INT64:    true,
	desc.FieldDescriptorProto_TYPE_INT32:    true,
	desc.FieldDescriptorProto_TYPE_UINT64:   true,
	desc.FieldDescriptorProto_TYPE_UINT32:   true,
	desc.FieldDescriptorProto_TYPE_SINT64:   true,
	desc.FieldDescriptorProto_TYPE_SINT32:   true,
	desc.FieldDescriptorProto_TYPE_FLOAT:    true,
	desc.FieldDescriptorProto_TYPE_DOUBLE:   true,
	desc.FieldDescriptorProto_TYPE_FIXED32:  true,
	desc.FieldDescriptorProto_TYPE_SFIXED32: true,
	desc.FieldDescriptorProto_TYPE_FIXED64:  true,
	desc.FieldDescriptorProto_TYPE_SFIXED64: true,
	desc.FieldDescriptorProto_TYPE_BOOL:     true,
	desc.FieldDescriptorProto_TYPE_ENUM:     true,
}

func (f *field) writeDecoder(w *writer, dec, wt string) {
	if f.isMap {
		w.p("$obj = new %s();", f.phpType())
		w.p("$obj->MergeFrom(%s->readDecoder());", dec)
		w.p("$this->%s[$obj->key] = $obj->value;", f.varName())
		return
	}
	if f.fd.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
		// This is different enough we handle it on it's own.
		if f.isRepeated() {
			w.p("$obj = new %s();", f.phpType())
			w.p("$obj->MergeFrom(%s->readDecoder());", dec)
			w.p("$this->%s []= $obj;", f.varName())
		} else {
			if f.isOneofMember() {
				// TODO: Subtle: technically this doesn't merge, it overwrites! Maybe consider
				// fixing this.
				w.p("$obj = new %s();", f.phpType())
				w.p("$obj->MergeFrom(%s->readDecoder());", dec)
				w.p("$this->%s = new %s($obj);", f.oneof.name, f.oneof.classNameForField(f))
			} else {
				w.p("if ($this->%s == null) $this->%s = new %s();", f.varName(), f.varName(), f.phpType())
				w.p("$this->%s->MergeFrom(%s->readDecoder());", f.varName(), dec)
			}
		}
		return
	}

	// TODO should we do wiretype checking here?
	reader := ""
	switch *f.fd.Type {
	case desc.FieldDescriptorProto_TYPE_STRING,
		desc.FieldDescriptorProto_TYPE_BYTES:
		reader = fmt.Sprintf("%s->readString()", dec)
	case desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_UINT64:
		reader = fmt.Sprintf("%s->readVarint()", dec)
	case desc.FieldDescriptorProto_TYPE_INT32:
		reader = fmt.Sprintf("%s->readVarint32Signed()", dec)
	case desc.FieldDescriptorProto_TYPE_UINT32:
		reader = fmt.Sprintf("%s->readVarint32()", dec)
	case desc.FieldDescriptorProto_TYPE_SINT64:
		reader = fmt.Sprintf("%s->readVarintZigZag64()", dec)
	case desc.FieldDescriptorProto_TYPE_SINT32:
		reader = fmt.Sprintf("%s->readVarintZigZag32()", dec)
	case desc.FieldDescriptorProto_TYPE_FLOAT:
		reader = fmt.Sprintf("%s->readFloat()", dec)
	case desc.FieldDescriptorProto_TYPE_DOUBLE:
		reader = fmt.Sprintf("%s->readDouble()", dec)
	case desc.FieldDescriptorProto_TYPE_FIXED32:
		reader = fmt.Sprintf("%s->readLittleEndianInt32Unsigned()", dec)
	case desc.FieldDescriptorProto_TYPE_SFIXED32:
		reader = fmt.Sprintf("%s->readLittleEndianInt32Signed()", dec)
	case desc.FieldDescriptorProto_TYPE_FIXED64,
		desc.FieldDescriptorProto_TYPE_SFIXED64:
		reader = fmt.Sprintf("%s->readLittleEndianInt64()", dec)
	case desc.FieldDescriptorProto_TYPE_BOOL:
		reader = fmt.Sprintf("%s->readBool()", dec)
	case desc.FieldDescriptorProto_TYPE_ENUM:
		reader = fmt.Sprintf("%s\\%s::XXX_FromInt(%s->readVarint())", f.typePhpNs, f.typePhpName, dec)
	default:
		panic(fmt.Errorf("unknown reader for fd type: %s", *f.fd.Type))
	}
	if f.isOneofMember() {
		w.p("$this->%s = new %s(%s);", f.oneof.name, f.oneof.classNameForField(f), reader)
		return
	}
	if !f.isRepeated() {
		w.p("$this->%s = %s;", f.varName(), reader)
		return
	}
	// Repeated
	packable := isPackable[*f.fd.Type]
	if packable {
		w.p("if (%s == 2) {", wt)
		w.p("$packed = %s->readDecoder();", dec)
		w.p("while (!$packed->isEOF()) {")
		w.pdebug("reading packed field")
		packedReader := strings.Replace(reader, dec, "$packed", 1) // Heh, kinda hacky.
		w.p("$this->%s []= %s;", f.varName(), packedReader)
		w.p("}")
		w.p("} else {")
	}
	w.p("$this->%s []= %s;", f.varName(), reader)
	if packable {
		w.p("}")
	}
}

func (f field) primitiveWriters(enc string) (string, string) {
	writer := ""
	switch *f.fd.Type {
	case desc.FieldDescriptorProto_TYPE_STRING,
		desc.FieldDescriptorProto_TYPE_BYTES:
		writer = fmt.Sprintf("%s->writeString($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_UINT64,
		desc.FieldDescriptorProto_TYPE_UINT32,
		desc.FieldDescriptorProto_TYPE_INT32:
		writer = fmt.Sprintf("%s->writeVarint($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_SINT64:
		writer = fmt.Sprintf("%s->writeVarintZigZag64($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_SINT32:
		writer = fmt.Sprintf("%s->writeVarintZigZag32($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_FLOAT:
		writer = fmt.Sprintf("%s->writeFloat($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_DOUBLE:
		writer = fmt.Sprintf("%s->writeDouble($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_FIXED32:
		writer = fmt.Sprintf("%s->writeLittleEndianInt32Unsigned($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_SFIXED32:
		writer = fmt.Sprintf("%s->writeLittleEndianInt32Signed($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_FIXED64,
		desc.FieldDescriptorProto_TYPE_SFIXED64:
		writer = fmt.Sprintf("%s->writeLittleEndianInt64($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_BOOL:
		writer = fmt.Sprintf("%s->writeBool($this->%s)", enc, f.varName())
	case desc.FieldDescriptorProto_TYPE_ENUM:
		writer = fmt.Sprintf("%s->writeVarint($this->%s)", enc, f.varName())
	default:
		panic(fmt.Errorf("unknown reader for fd type: %s", *f.fd.Type))
	}
	tagWriter := fmt.Sprintf("%s->writeTag(%d, %d);", enc, *f.fd.Number, writeWireType[f.fd.GetType()])
	return tagWriter, writer
}

// Oneofs are a subset of all field types, and they serialize their default
// value to the wire.
func (f field) writeEncoderForOneof(w *writer, enc string) {
	if f.fd.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
		w.p("$nested = new %s\\Encoder();", libNsInternal)
		w.p("$this->%s->WriteTo($nested);", f.fd.GetName())
		w.p("%s->writeEncoder($nested, %d);", enc, f.fd.GetNumber())
		return
	}

	tagWriter, writer := f.primitiveWriters("$e")
	w.p(tagWriter + ";")
	w.p(writer + ";")
}

func (f field) writeEncoder(w *writer, enc string) {
	if f.isMap {
		w.p("foreach ($this->%s as $k => $v) {", f.varName())
		w.p("$obj = new %s();", f.phpType())
		w.p("$obj->key = $k;")
		w.p("$obj->value = $v;")
		w.p("$nested = new %s\\Encoder();", libNsInternal)
		w.p("$obj->WriteTo($nested);")
		w.p("%s->writeEncoder($nested, %d);", enc, f.fd.GetNumber())
		w.p("}")
		return
	}

	if f.fd.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
		// This is different enough we handle it on it's own.
		// TODO we could optimize to not to string copies.
		if f.isRepeated() {
			w.p("foreach ($this->%s as $msg) {", f.varName())
		} else {
			w.p("$msg = $this->%s;", f.varName())
			w.p("if ($msg != null) {")
		}
		w.p("$nested = new %s\\Encoder();", libNsInternal)
		w.p("$msg->WriteTo($nested);")
		w.p("%s->writeEncoder($nested, %d);", enc, f.fd.GetNumber())
		w.p("}")
		return
	}

	tagWriter, writer := f.primitiveWriters(enc)

	if !f.isRepeated() {
		w.p("if ($this->%s !== %s) {", f.varName(), f.defaultValue())
		w.p(tagWriter)
		w.p("%s;", writer)
		w.p("}")
		return
	}
	// Repeated
	// Heh, kinda hacky.
	repeatWriter := strings.Replace(writer, "$this->"+f.varName(), "$elem", 1)
	if isPackable[*f.fd.Type] {
		// Heh, kinda hacky.
		packedWriter := strings.Replace(repeatWriter, enc, "$packed", 1)
		w.p("$packed = new %s\\Encoder();", libNsInternal)
		w.p("foreach ($this->%s as $elem) {", f.varName())
		w.pdebug("writing packed")
		w.p("%s;", packedWriter)
		w.p("}")
		w.p("%s->writeEncoder($packed, %d);", enc, *f.fd.Number)
	} else {
		w.p("foreach ($this->%s as $elem) {", f.varName())
		w.p(tagWriter)
		w.p("%s;", repeatWriter)
		w.p("}")
	}
}

func (f *field) jsonReader(v string) string {
	rt := ""
	switch f.fd.GetType() {
	case
		desc.FieldDescriptorProto_TYPE_STRING,
		desc.FieldDescriptorProto_TYPE_BYTES:
		rt = "String"
	case
		desc.FieldDescriptorProto_TYPE_UINT32,
		desc.FieldDescriptorProto_TYPE_INT32,
		desc.FieldDescriptorProto_TYPE_SINT32,
		desc.FieldDescriptorProto_TYPE_SFIXED32,
		desc.FieldDescriptorProto_TYPE_FIXED32:
		rt = "Int32"
	case
		desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_SINT64,
		desc.FieldDescriptorProto_TYPE_SFIXED64:
		rt = "Int64Signed"
	case
		desc.FieldDescriptorProto_TYPE_UINT64,
		desc.FieldDescriptorProto_TYPE_FIXED64:
		rt = "Int64Unsigned"
	case desc.FieldDescriptorProto_TYPE_FLOAT,
		desc.FieldDescriptorProto_TYPE_DOUBLE:
		rt = "Float"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		rt = "Bool"
	case
		desc.FieldDescriptorProto_TYPE_ENUM:
		return fmt.Sprintf("%s\\%s::XXX_FromMixed(%s)", f.typePhpNs, f.typePhpName, v)
	default:
		panic(fmt.Errorf("bad json reader: %v", f.fd.GetType()))
	}
	return fmt.Sprintf("%s\\JsonDecoder::read%s(%s)", libNsInternal, rt, v)
}

func (f *field) writeJsonDecoder(w *writer, v string) {
	if f.isMap {
		k, vv := f.mapFields()
		w.p("foreach (%s\\JsonDecoder::readObject(%s) as $k => $v) {", libNsInternal, v)
		if vv.fd.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
			w.p("$obj = new %s();", vv.phpType())
			w.p("$obj->MergeJsonFrom(%s\\JsonDecoder::readDecoder(%s));", libNsInternal, v)
			w.p("$this->%s[%s] = $obj;", f.fd.GetName(), k.jsonReader("$k"))
		} else {
			w.p("$this->%s[%s] = %s;", f.fd.GetName(), k.jsonReader("$k"), vv.jsonReader("$v"))
		}
		w.p("}")
		return
	}
	if f.fd.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
		if f.isRepeated() {
			w.p("$obj = new %s();", f.phpType())
			w.p("$obj->MergeJsonFrom(%s\\JsonDecoder::readDecoder(%s));", libNsInternal, v)
			w.p("$this->%s []= $obj;", f.varName())
		} else {
			if f.isOneofMember() {
				// TODO: Subtle: technically this doesn't merge, it overwrites!
				w.p("$obj = new %s();", f.phpType())
				w.p("$obj->MergeJsonFrom(%s\\JsonDecoder::readDecoder(%s));", libNsInternal, v)
				w.p("$this->%s = new %s($obj);", f.oneof.name, f.oneof.classNameForField(f))
			} else {
				w.p("if ($this->%s == null) $this->%s = new %s();", f.varName(), f.varName(), f.phpType())
				w.p("$this->%s->MergeJsonFrom(%s\\JsonDecoder::readDecoder(%s));", f.varName(), libNsInternal, v)
			}
		}
		return
	}

	if f.isRepeated() {
		w.p("foreach(%s\\JsonDecoder::readList(%s) as $vv) {", libNsInternal, v)
		w.p("$this->%s []= %s;", f.varName(), f.jsonReader("$vv"))
		w.p("}")
	} else {
		if f.isOneofMember() {
			// TODO: Subtle: technically this doesn't merge, it overwrites!
			w.p("$this->%s = new %s(%s);", f.oneof.name, f.oneof.classNameForField(f), f.jsonReader(v))
		} else {
			w.p("$this->%s = %s;", f.varName(), f.jsonReader(v))
		}
	}
}

func (f field) jsonWriter() (string, string) {
	switch t := f.fd.GetType(); t {
	case desc.FieldDescriptorProto_TYPE_STRING,
		desc.FieldDescriptorProto_TYPE_BYTES:
		return "String", "Primitive"
	case
		desc.FieldDescriptorProto_TYPE_UINT32,
		desc.FieldDescriptorProto_TYPE_INT32,
		desc.FieldDescriptorProto_TYPE_SINT32,
		desc.FieldDescriptorProto_TYPE_SFIXED32,
		desc.FieldDescriptorProto_TYPE_FIXED32:
		return "Int32", "Primitive"
	case
		desc.FieldDescriptorProto_TYPE_INT64,
		desc.FieldDescriptorProto_TYPE_SINT64,
		desc.FieldDescriptorProto_TYPE_SFIXED64:
		return "Int64Signed", "Int64Signed"
	case
		desc.FieldDescriptorProto_TYPE_UINT64,
		desc.FieldDescriptorProto_TYPE_FIXED64:
		return "Int64Unsigned", "Int64Unsigned"
	case desc.FieldDescriptorProto_TYPE_FLOAT,
		desc.FieldDescriptorProto_TYPE_DOUBLE:
		return "Float", "Float"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		return "Bool", "Primitive"
	case desc.FieldDescriptorProto_TYPE_MESSAGE:
		return "Message", "Message"
	case desc.FieldDescriptorProto_TYPE_ENUM:
		return "Enum", "Enum"
	default:
		panic(fmt.Errorf("unexpected proto type: %v", t))
	}
}

func (f field) writeJsonEncoder(w *writer, enc string, forceEmitDefault bool) {
	if f.isMap {
		k, v := f.mapFields()
		_, manyWriter := v.jsonWriter()
		if manyWriter == "Enum" {
			itos := v.typePhpNs + "\\" + v.typePhpName + "::XXX_ItoS()"
			w.p("%s->writeEnumMap('%s', '%s', %s, $this->%s);", enc, f.fd.GetName(), f.fd.GetJsonName(), itos, f.varName())
		} else {
			if k.fd.GetType() == desc.FieldDescriptorProto_TYPE_BOOL {
				w.p("/* HH_FIXME[4110] bool is not arraykey */") // TODO fix this.
			}
			w.p("%s->write%sMap('%s', '%s', $this->%s);", enc, manyWriter, f.fd.GetName(), f.fd.GetJsonName(), f.varName())
		}
		return
	}

	writer, manyWriter := f.jsonWriter()

	emitDefault := ", false"
	if forceEmitDefault {
		emitDefault = ", true"
	}
	repeated := ""
	if f.isRepeated() {
		repeated = "List"
		writer = manyWriter
		emitDefault = ""
	}

	if writer == "Enum" {
		itos := f.typePhpNs + "\\" + f.typePhpName + "::XXX_ItoS()"
		w.p("%s->writeEnum%s('%s', '%s', %s, $this->%s%s);", enc, repeated, f.fd.GetName(), f.fd.GetJsonName(), itos, f.varName(), emitDefault)
	} else {
		w.p("%s->write%s%s('%s', '%s', $this->%s%s);", enc, writer, repeated, f.fd.GetName(), f.fd.GetJsonName(), f.varName(), emitDefault)
	}
}

func (f field) isOneofMember() bool {
	return f.fd.OneofIndex != nil
}

// writeEnum writes an enumeration type and constants definitions.
func writeEnum(w *writer, ed *desc.EnumDescriptorProto, prefixNames []string) {
	name := strings.Join(append(prefixNames, *ed.Name), "_")
	typename := specialPrefix + name + "_t"
	w.p("newtype %s as int = int;", typename)
	w.p("abstract class %s {", name)
	for _, v := range ed.Value {
		w.p("const %s %s = %d;", typename, *v.Name, *v.Number)
	}

	w.p("private static dict<int, string> $XXX_itos = dict[")
	w.i++
	for _, v := range ed.Value {
		w.p("%d => '%s',", v.GetNumber(), v.GetName())
	}
	w.i--
	w.p("];")

	w.p("public static function XXX_ItoS(): dict<int, string> {")
	w.p("return self::$XXX_itos;")
	w.p("}")

	w.p("private static dict<string, int> $XXX_stoi = dict[")
	w.i++
	for _, v := range ed.Value {
		w.p("'%s' => %d,", v.GetName(), v.GetNumber())
	}
	w.i--
	w.p("];")

	w.p("public static function XXX_FromMixed(mixed $m): %s {", typename)
	w.p("if (is_string($m)) return idx(self::$XXX_stoi, $m, is_numeric($m) ? ((int) $m) : 0);")
	w.p("if (is_int($m)) return $m;")
	w.p("return 0;")
	w.p("}")

	w.p("public static function XXX_FromInt(int $i): %s {", typename)
	w.p("return $i;")
	w.p("}")
	w.p("}")
	w.ln()
}

type oneof struct {
	descriptor                                                  *desc.OneofDescriptorProto
	fields                                                      []*field
	name, interfaceName, enumTypeName, classPrefix, notsetClass string
	// v2
}

const notsetEnum = specialPrefix + "NOT_SET"

func (o *oneof) classNameForField(f *field) string {
	return o.classPrefix + f.fd.GetName()
}

func writeOneofTypes(w *writer, oo *oneof) {
	// The interface.
	w.p("newtype %s = int;", oo.enumTypeName)
	w.p("interface %s {", oo.interfaceName)
	w.p("const %s %s = 0;", oo.enumTypeName, notsetEnum)
	for _, field := range oo.fields {
		w.p("const %s %s = %d;", oo.enumTypeName, field.fd.GetName(), field.fd.GetNumber())
	}

	w.p("public function WhichOneof(): %s;", oo.enumTypeName)
	w.p("public function WriteTo(%s\\Encoder $e): void;", libNsInternal)
	w.p("public function WriteJsonTo(%s\\JsonEncoder $e): void;", libNsInternal)
	w.p("}")

	w.ln()
	// Notset case:
	w.p("class %s implements %s {", oo.notsetClass, oo.interfaceName)

	w.p("public function WhichOneof(): %s {", oo.enumTypeName)
	w.p("return self::%s;", notsetEnum)
	w.p("}")
	w.ln()

	w.p("public function WriteTo(%s\\Encoder $e): void {}", libNsInternal)
	w.ln()

	w.p("public function WriteJsonTo(%s\\JsonEncoder $e): void {}", libNsInternal)
	// todo!
	w.p("}")

	// An implementation per field.
	for _, f := range oo.fields {
		w.p("class %s implements %s {", oo.classNameForField(f), oo.interfaceName)
		w.p("public function __construct(public %s $%s) {}", f.phpType(), f.varName())
		w.ln()

		w.p("public function WhichOneof(): %s {", oo.enumTypeName)
		w.p("return self::%s;", f.fd.GetName())
		w.p("}")
		w.ln()

		w.p("public function WriteTo(%s\\Encoder $e): void {", libNsInternal)
		f.writeEncoderForOneof(w, "$e")
		w.p("}")
		w.ln()

		w.p("public function WriteJsonTo(%s\\JsonEncoder $e): void {", libNsInternal)
		f.writeJsonEncoder(w, "$e", true)
		w.p("}")

		w.p("}")
		w.ln()
	}
}

// https://github.com/golang/protobuf/blob/master/protoc-gen-go/descriptor/descriptor.pb.go
func writeDescriptor(w *writer, dp *desc.DescriptorProto, ns *Namespace, prefixNames []string) {
	nextNames := append(prefixNames, dp.GetName())
	name := strings.Join(nextNames, "_")

	// Nested Enums.
	for _, edp := range dp.EnumType {
		writeEnum(w, edp, nextNames)
	}

	// Wrap fields in our own struct.
	fields := []*field{}
	for _, fd := range dp.Field {
		fields = append(fields, newField(fd, ns))
	}

	// Oneofs: first group each field by it's corresponding oneof.
	oneofFields := map[int32][]*field{}
	for _, field := range fields {
		if !field.isOneofMember() {
			continue
		}
		i := field.fd.GetOneofIndex()
		l := oneofFields[i]
		l = append(l, field)
		oneofFields[i] = l
	}

	// Write oneof types.
	oneofs := []*oneof{}
	for i, od := range dp.OneofDecl {
		oneofName := strings.Join(append(nextNames, od.GetName()), "_")
		oo := &oneof{
			descriptor:    od,
			name:          od.GetName(),
			fields:        oneofFields[int32(i)],
			interfaceName: oneofName,
			enumTypeName:  specialPrefix + oneofName + "_enum_t",
			classPrefix:   strings.Join(nextNames, "_") + "_",
			notsetClass:   specialPrefix + oneofName + "_" + "NOT_SET",
		}
		oneofs = append(oneofs, oo)
		writeOneofTypes(w, oo)
	}

	// Now point each field at it's oneof.
	for _, field := range fields {
		if field.isOneofMember() {
			field.oneof = oneofs[field.fd.GetOneofIndex()]
		}
	}

	// Nested Types.
	for _, ndp := range dp.NestedType {
		writeDescriptor(w, ndp, ns, nextNames)
	}

	// w.p("// message %s", dp.GetName())
	w.p("class %s implements %s\\Message {", name, libNs)

	// Members
	for _, f := range fields {
		if f.isOneofMember() {
			continue
		}
		// w.p("// field %s = %d", f.fd.GetName(), f.fd.GetNumber())
		w.p("public %s $%s;", f.labeledType(), f.varName())
	}
	for _, oo := range oneofs {
		w.p("public %s $%s;", oo.interfaceName, oo.name)
	}
	w.ln()

	// Constructor.
	w.p("public function __construct() {")
	for _, f := range fields {
		if f.isOneofMember() {
			continue
		}
		w.p("$this->%s = %s;", f.varName(), f.defaultValue())
	}
	for _, oo := range oneofs {
		w.p("$this->%s = new %s();", oo.name, oo.notsetClass)
	}
	w.p("}")
	w.ln()

	// Now sort the fields by number.
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].fd.GetNumber() < fields[j].fd.GetNumber()
	})

	// MergeFrom function
	w.p("public function MergeFrom(%s\\Decoder $d): void {", libNsInternal)
	w.p("while (!$d->isEOF()){")
	w.p("list($fn, $wt) = $d->readTag();")
	w.p("switch ($fn) {")
	for _, f := range fields {
		w.p("case %d:", f.fd.GetNumber())
		w.i++
		w.pdebug("reading field:%d (%s) wiretype:$wt of %s", f.fd.GetNumber(), f.varName(), dp.GetName())
		f.writeDecoder(w, "$d", "$wt")
		w.pdebug("read field:%d (%s) of %s", f.fd.GetNumber(), f.varName(), dp.GetName())
		w.p("break;")
		w.i--
	}
	w.p("default:")
	w.i++
	w.pdebug("skipping unknown field:$fn wiretype:$wt")
	w.p("$d->skipWireType($wt);")
	w.i--
	w.p("}") // switch
	w.p("}") // while
	w.p("}") // function MergeFrom
	w.ln()

	// WriteTo function
	w.p("public function WriteTo(%s\\Encoder $e): void {", libNsInternal)
	for _, f := range fields {
		if f.isOneofMember() {
			continue
		}
		w.pdebug("maybe writing field:%d (%s) of %s", f.fd.GetNumber(), f.varName(), dp.GetName())
		f.writeEncoder(w, "$e")
		w.pdebug("maybe wrote field:%d (%s) of %s", f.fd.GetNumber(), f.varName(), dp.GetName())
	}
	for _, oo := range oneofs {
		w.p("$this->%s->WriteTo($e);", oo.name)
	}
	w.p("}") // WriteToFunction
	w.ln()

	// WriteJsonTo function
	w.p("public function WriteJsonTo(%s\\JsonEncoder $e): void {", libNsInternal)
	for _, f := range fields {
		if f.isOneofMember() {
			continue
		}
		f.writeJsonEncoder(w, "$e", false)
	}
	for _, oo := range oneofs {
		w.p("$this->%s->WriteJsonTo($e);", oo.name)
	}
	w.p("}") // WriteJsonToFunction
	w.ln()

	// MergeJsonFrom function
	w.p("public function MergeJsonFrom(%s\\JsonDecoder $d): void {", libNsInternal)
	w.p("foreach ($d->d as $k => $v) {")
	w.p("switch ($k) {")
	for _, f := range fields {
		ca := fmt.Sprintf("case '%s':", f.fd.GetName())
		if f.fd.GetName() != f.fd.GetJsonName() {
			ca += fmt.Sprintf(" case '%s':", f.fd.GetJsonName())
		}
		w.p(ca)
		w.i++

		f.writeJsonDecoder(w, "$v")
		w.p("break;")
		w.i--
	}
	w.p("}")
	w.p("}")
	w.p("}")

	w.p("}") // class
	w.ln()
}

type method struct {
	mdp                                  *desc.MethodDescriptorProto
	PhpName, InputPhpName, OutputPhpName string
}

func newMethod(mdp *desc.MethodDescriptorProto, ns *Namespace) method {
	m := method{mdp: mdp}
	m.PhpName = mdp.GetName()
	tns, tn, _ := ns.FindFullyQualifiedName(mdp.GetInputType())
	tns, tn = toPhpName(tns, tn)
	m.InputPhpName = tns + "\\" + tn
	tns, tn, _ = ns.FindFullyQualifiedName(mdp.GetOutputType())
	tns, tn = toPhpName(tns, tn)
	m.OutputPhpName = tns + "\\" + tn
	return m
}

func (m method) isStreaming() bool {
	return m.mdp.GetClientStreaming() || m.mdp.GetServerStreaming()
}

func writeService(w *writer, sdp *desc.ServiceDescriptorProto, pkg string, ns *Namespace) {
	methods := []method{}
	for _, mdp := range sdp.Method {
		methods = append(methods, newMethod(mdp, ns))
	}
	fqname := sdp.GetName()
	if pkg != "" {
		fqname = pkg + "." + fqname
	}

	isReflectionApi := fqname == "grpc.reflection.v1alpha.ServerReflection"

	// Client
	w.p("class %sClient {", sdp.GetName())
	w.p("public function __construct(private \\Grpc\\ClientConn $cc) {")
	w.p("}")
	for _, m := range methods {
		if m.isStreaming() {
			continue
		}
		w.ln()
		w.p("public async function %s(\\Grpc\\Context $ctx, %s $in, \\Grpc\\CallOption ...$co): Awaitable<%s> {", m.PhpName, m.InputPhpName, m.OutputPhpName)
		w.p("$out = new %s();", m.OutputPhpName)
		w.p("await $this->cc->Invoke($ctx, '/%s/%s', $in, $out, ...$co);", fqname, m.mdp.GetName())
		w.p("return $out;")
		w.p("}")
	}
	w.p("}")
	w.ln()

	// Server
	w.p("interface %sServer {", sdp.GetName())
	for _, m := range methods {
		if m.isStreaming() && !isReflectionApi {
			continue
		}
		w.p("public function %s(\\Grpc\\Context $ctx, %s $in): %s;", m.PhpName, m.InputPhpName, m.OutputPhpName)
	}
	w.p("}")
	w.ln()

	w.p("function Register%sServer(\\Grpc\\Server $server, %sServer $service): void {", sdp.GetName(), sdp.GetName())
	w.p("$methods = vec[];")
	for _, m := range methods {
		if m.isStreaming() && !isReflectionApi {
			continue
		}
		w.p("$handler = function(\\Grpc\\Context $ctx, \\Grpc\\DecoderFunc $df): %s\\Message use ($service) {", libNs)
		w.p("$in = new %s();", m.InputPhpName)
		w.p("$df($in);")
		w.p("return $service->%s($ctx, $in);", m.PhpName)
		w.p("};")
		w.p("$methods []= new \\Grpc\\MethodDesc('%s', $handler);", m.PhpName)
	}
	w.p("$server->RegisterService(new \\Grpc\\ServiceDesc('%s', $methods));", fqname)
	w.p("}")
}

// writer is a little helper for output printing. It indents code
// appropriately among other things.
type writer struct {
	w io.Writer
	i int
}

func (w *writer) p(format string, a ...interface{}) {
	if strings.HasPrefix(format, "}") {
		w.i--
	}
	i := w.i
	if i < 0 {
		i = 0
	}
	indent := strings.Repeat("  ", i)
	fmt.Fprintf(w.w, indent+format, a...)
	w.ln()
	if strings.HasSuffix(format, "{") {
		w.i++
	}
}

func (w *writer) ln() {
	fmt.Fprintln(w.w)
}

func (w *writer) pdebug(format string, a ...interface{}) {
	if !genDebug {
		return
	}
	w.p(fmt.Sprintf(`echo "DEBUG: %s\n";`, format), a...)
}
